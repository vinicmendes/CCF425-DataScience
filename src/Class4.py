# -*- coding: utf-8 -*-
"""

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mtDPWFXkTHgFohHL_RaOe7WlRewG9Rnt
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats import norm

ia171 = pd.read_csv('./atraso_ia171.csv', index_col=False, header=None, squeeze=True)
ie666 = pd.read_csv('./atraso_ie666.csv', index_col=False, header=None, squeeze=True)
bitcomb = pd.read_csv('./tempo_bitcomb.csv', index_col=False, header=None, squeeze=True)
combinar = pd.read_csv('./tempo_combinar.csv', index_col=False, header=None, squeeze=True)

"""1. Você foi alocado no trabalho para decidir sobre qual protocolo de comunicação utilizar para a infraestrutura de IoT que será implantada na sua empresa. As duas opções são os protocolos IA171 e o IE666. O principal critério para a sua empresa é o atraso na transmissão. Então, você implementa os dois protocolos em um simulador de redes e coleta 100 valores de atrasos de transmissão para cada protocolo. Com base nesses valores, você deve decidir qual protocolo utilizar. Faça a análise desses resultados e elabore uma justificativa plausível e quantitativa para a utilização de um ou outro protocolo, ou se não há diferença significativa que indique que um protocolo é melhor que o outro. Os resultados de atrasos estão em milissegundos nos arquivos atraso_ia171.csv atraso_ie666.csv. A empresa espera que você tenha uma confiança de 95% em sua decisão.

Hipótese Nula: O atraso dos 2 protocolos são iguais

Hipótese Alternativa: O atraso dos 2 protocolos são diferentes.
"""

ia171.describe()

ie666.describe()

mean_ia171 = ia171.mean()
mean_ie666 = ie666.mean()

erro_padrao_ia171 = ia171.std()/np.sqrt(ia171.shape[0])
erro_padrao_ie666 = ie666.std()/np.sqrt(ie666.shape[0])

erro_padrao_medias = (mean_ia171 - mean_ie666)/np.sqrt((erro_padrao_ia171/ia171.shape[0]) + (erro_padrao_ie666/ie666.shape[0]))

print(f"P-value: {norm.cdf(erro_padrao_medias)}")

"""Logo, rejeitamos a hipótese nula, visto que, há diferença entre ambos os atrasos e que o IE666 possui os melhores valores.

2. Você precisa implementar um algoritmo para calcular todas as possibilidades de senhas existentes considerando somente números e letras, de no máximo tamanho 8. Como um bom aluno que você é, você pesquisa no Google e encontra duas implementações prontas: CombNar e BitComb. Você então prepara vários testes para comparar os dois algoritmos em termos do tempo de execução em segundos. Os resultados de 100 execuções de cada algoritmo estão armazenados nos arquivos tempo_combinar.csv e tempo_bitcomb.csv. Com base nesses resultados, qual dos dois algoritmos você escolhe? Justifique sua resposta.
"""

bitcomb.describe()

combinar.describe()

"""Hipótese Nula: O tempo dos 2 algoritmos são iguais

Hipótese Alternativa: O tempo dos 2 são diferentes.
"""

mean_bitcomb = bitcomb.mean()
mean_combinar = combinar.mean()

erro_padrao_bitcomb = bitcomb.std()/np.sqrt(bitcomb.shape[0])
erro_padrao_combinar = combinar.std()/np.sqrt(combinar.shape[0])

erro_padrao_medias = (mean_bitcomb - mean_combinar)/np.sqrt((erro_padrao_bitcomb/bitcomb.shape[0]) + (erro_padrao_combinar/combinar.shape[0]))

print(f"P-value: {norm.cdf(erro_padrao_medias)}")

"""P-value < que 0.05 indica que aceitamos a hipótese nula, logo, qualquer algoritmo poderá ser escolhido igualmente."""